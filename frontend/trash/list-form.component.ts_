import { AbstractControl } from '@angular/forms';
import { buildTitleMap, isArray } from '@ajsf/core';
import { Component, Input, OnInit } from '@angular/core';
import { JsonSchemaFormService } from '@ajsf/core';
import { HttpClient } from "@angular/common/http";
import { ListFormService } from '../../../services/list-form.service';
import { FormArray, FormGroup, FormBuilder } from "@angular/forms";
import { mergeMap, startWith, pairwise, switchMap, debounceTime, distinctUntilChanged } from "@librairies/rxjs/operators";
import { of, Subject } from "@librairies/rxjs";
import utils from "../../../utils"
@Component({
  selector: 'list-form',
  templateUrl: 'list-form.component.html',
  styleUrls: ['list-form.component.scss'],
})
export class ListFormComponent implements OnInit {
  formControl: AbstractControl;
  controlName: string;
  controlValue: any;
  controlDisabled = false;
  boundControl = false;
  options: any;
  selectList: any[] = [];

  firstChange = true;

  // pour pouvoir filter en local
  selectListSave: any[] = [];

  isLoading=false;



  search = '';
  model=null;
  selectedItems: [];

  searchSubject: Subject<string>;

  isArray = isArray;
  @Input() layoutNode: any;
  @Input() layoutIndex: number[];
  @Input() dataIndex: number[];

  constructor(
    private jsf: JsonSchemaFormService,
    private _listFormService: ListFormService,
    private _fb: FormBuilder,
  ) { }

  ngOnInit() {
    this.searchSubject = new Subject();
    this.options = this.layoutNode.options || {};
    // this.selectList = buildTitleMap(
    //   this.options.titleMap || this.options.enumNames,
    //   this.options.enum, !!this.options.required, !!this.options.flatList
    // );

    this.options.search = this.search;

    if (!this.options.notitle && !this.options.description && this.options.placeholder) {
      this.options.description = this.options.placeholder;
    }

    this.jsf.initializeControl(this, !this.options.readonly);

    /**
     * ici set time out pour temporiser après l'initialisation de jsf
     * et être sûr d'avoir une valeur pour controlValue (ou formControl.value0)
     */

    setTimeout(()=>{

      // patch valeur init buggée
      if (this.options.return_object && this.options.multiple) {
        if (this.formControl.value.length == 1 && this.formControl.value[0][this.options.value_field_name] == null) {
          this.updateValue([]);
        }
      }

    this.searchSubject.pipe(
      distinctUntilChanged(),
      debounceTime(400),
      switchMap((search) => {
        return this.processSearchChanged(search);
      })
    ).subscribe(()=> {});

    this._listFormService.initListForm(this.options, this.formControl)
      .subscribe(({selectList, model}) => {

        this.selectList = (selectList as any[]);
        this.selectListSave = utils.copy(selectList as any[]);
        this.model = model;

        this.formControl.valueChanges
          .pipe(startWith(null as string), pairwise())
          .subscribe(([prev, next]: [any, any]) => {
            if(this.firstChange) {
              this.firstChange=false;
              return;
            }
            if(utils.fastDeepEqual(prev, next) && !utils.fastDeepEqual(next, this.controlValue)) {
              this.updateModel(next);
              return
            }
          });
      });
    });
  }

  updateModel(val) {
    return  this._listFormService.formToModel(this.options, val)
      .subscribe((model)=> {
        this.updateValue(model);
      });
  }

  searchChanged(event) {
    this.search = event;

    this.searchSubject.next(event);
  }

  processSearchChanged(search) {
    // filtrage server side
    if (this.options.data_reload_on_search && this.options.api && event != this.options.search) {
      this.options.search=search;
      this.isLoading = true;
      return this._listFormService.getSelectList(this.options, this.model)
      .pipe(
        mergeMap((selectList) => {
          this.isLoading = false;
          this.selectList = selectList;
          this.jsf.updateValue(this, this.controlValue);
          return of(true);
        })
      );
    }
    // filtrage local
    else {
      const searchLowerUnaccent = utils.lowerUnaccent(search);
      this.selectList =this.selectListSave.filter(item => {
        const label = item[this.options.label_field_name].toLowerCase()
        return (
          !searchLowerUnaccent
          || utils.lowerUnaccent(label).includes(searchLowerUnaccent)
        )
      });
      return of(true);
    }
  }

  clearModel(event) {
    event.stopPropagation();
    this.updateValue(this.options.multiple ? [] : null);
  }

  onBlur(event) {
    this.options.showErrors = true;
  }

  updateValue(event) {
    if(this.controlName == 'id_role') {
      console.log('up', event)
    }
    this.model = event;
    this.options.showErrors = true;
    let value = this._listFormService.modelToForm(this.options, this.model)

    // patch clear
    if (this.options.return_object && this.options.multiple) {
      const formArray = this.jsf.getFormControl(this) as FormArray;
      while (formArray.controls.length > 0) {
        formArray.removeAt(0);
      }
      value.forEach((v, i) => {
        formArray.setControl(i, this._fb.group(v))
        formArray.patchValue(value)
      });
    }

    this.jsf.updateValue(this, value);
  }
}
