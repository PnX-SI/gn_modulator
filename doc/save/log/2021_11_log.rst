Bilan novembre 2021
===================

Les schémas
-----------


Définition
~~~~~~~~~~

Un dictionnaire permettant de définir les éléments suivants:

- properties
  - les colonnes (entier, nombre, uuid, date, geometrie)
  - les relations avec d'autres schemas
    - 1-n
    - n-1
    - n-n (correlation)

- meta
  - label (nom pour l'affichage dans le frontend
  - sql ( nom du schema, nom de la table)
  - etc ..

Ces schémas de définition permettent de générer les éléments suivants:

- schéma de validation et de formulaire (à peu près semblable)
- code sql définissant les tables et les contraintes
- modèle sqlalchemy
- repository ou requetes sqlalchemy
    - les requêtes sur une ligne get one row, insert_row, update_row, delete_row
    - les demande de listes
        - gestion des filtres et des tris
- serializer / déserializer marshmallow
- api rest appliccant les méthode du repository et des serializer
    - GET (list), GET (one), POST, PATCH, delete_row
    - api pour récupérer la config

Schémas
~~~~~~~

- validations: permet de valider les données arrivant des api POST PATCH ou des imports
- form: à utiliser avec le composant ajsf

Une légère différence existe entre ces deux schéma (du à la mauvaise compréhension des 'oneOf' par ajsf )

Code sql
~~~~~~~~

- pour le schéma et les schémas dont dépend ce dernière
- Ce code est constitué dans l'ordre de:
    - création de tables
    - contraintes de clé primaires
    - contraintes de clé étrangères
    - contraintes de type nomenclatures
    - tables de correlation
        - contraintes de clé étrangères sur ces tables

Modèles sqlalchemy
~~~~~~~~~~~~~~~~~~

- Le schema de définition permet de créer un modèles sqlalchemy avec
    - les colonnes
        - string, integer, float, geometrie, date
        - clé primaire, clé étrangère
        - geometrie
    - les relations avec les autres schemas

- Une mise en cache des modèles permet de
  - ne pas recréer un modèles déjà exister
  - d'éviter les dépendances circulaires (avec les relations)
  - gangner du temps

Repository et requêtes sqlalchemy
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A partir d'un modèle on peut faire des requêtes sqlalchemy permettant de

- faire des actions sur une ligne:
    - récupérer une ligne
    - insérer une ligne
    - modifier une ligne
    - supprimer une ligne

la ligne peut être identifié par une valeur correspondant à un champs donné (par défaut la clé primaire)

- demander une liste de ligne en spécifiant
    - des filtres:
        - un filtre est défini par un dictionnaire :
              - ``type``: ('=', 'like', 'ilike', '>=', '>', '<', '<=')
              - ``field``:  une colonne (peut être aussi une colonne d'une relation (``rel.rel_name``)
              - ``value``: une valeur
        - ces filtres peuvent être combinés selon les règles de la logique ( ET, OU, NON, parenthèses)
    - des tris:
        - un tri est défini par
              - ``field``: une colonne (peut être aussi une colonne d'une relation (``rel.rel_name``)
              -  ``dir``: une direction

Serializers et deserializers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A partir du schema de definition et du modèle ou peut définir des sérializer à l'aide des schemas marshmallow.

- sérializer:
    - gère les types:
        - entier, string, date, geometrie
    - listes
        - possibilité de choisir les champs pour limiter les sorties
            - clé d'une colonne: ``<col_name>``
            - clé d'une colonne d'une relation

- deserializers:
    - pour charger les données dans un modèle sqlalchemy

api
---

api config

api rest


Les modules
-----------

Definitions
~~~~~~~~~~~

- un ensemble de schémas
- possibilité de redéfinir des points de config
    - par exemple layout

- hierachie entre les schemas

::

    - site: {
      - visite: {
          - observation
    }


- sert pour le breadcrumb
- implique
    - site : il exisite une (unique) relation 1-n avec les  visites
    - il existe la relation opposée (n-1) avec les sorties
    - quid des correlations
    - etc...

- page pour un schema
    - url
    modules/<module_code>/site/
::

  elems: [
  { elem: site.map, postion: G, value=<id> },
  { elem: site.properties, postion: DH },
  { elem: visit.table, elem: visit, filters: [id_site=<id>, jdd] postion: DB },

  ]


avec <id> associés aux parametres de route ?

positions
- D : droite
- G : gauche
- B ; bas
- H : haut

- DB : en bas à droite
- DH : en haut à droite
- GB : en bas à gauche
- GH : en haut à gauche

- regles
    - si D pas de DH ou DB
    - etc